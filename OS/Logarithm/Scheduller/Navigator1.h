//As the scheduller file contains a lot of functions and as we use physics, we can approximate a navigator behaviour by
//some secure methods because we return getExp11 instead of returning exp(11^2). It means that those methods are linked.
//Then, Internet contents can be linked with some heat power formulas. It seems the more easiest way. Thats why we can put
//them in a scheduller folder.
//The graphical contents can be rendered with my game engine. we have then to create a GPU library later.

void secureInternetContentsByApproximateLogX()
{
  //adding extra code to secure medical datas. Here, this is device commands by stack. Stacks are described in the next function
  
  
  //In CG, .... (I have to check other programs)...

  
  //We can use some scheduller methods because 
  
}


void GPUSendCommandsReleasingPotentialStacks( char* commands )
{
    //It seems that in the GPUs, it is best to work on stacks because it limits the numbers of computing requests (see notes of supercomput'er repository).
  Stack s;

  //an algorithm to exchange stacks can be model filled with heat transfer formulas.
  //As the scheduler can handle commands with 2 directions twice, it is able to trace the message queue
  //Then, we can design a low level arbitrary signal by reducing the size of the full latent variables numbers. It means
  //that we have to handle at least 2*2 - 2 , then 2 models ! This case was already handled in a previous stuff.
  //It then means that we have to secure 2 stacks first with RK4 ! we can use smart pointers to validate 
  //the contents and the signal from scratch will be a momentum. I hope that I m not wrong.

  RK4_secure_stack( entry_queue->getAngularMomentum(), ..);
  RK4_secure_stack( output_queue->getAngularMomentum(), ..);


  //we already proved in the readdme file that physics is best suited for OS design.
  //so now, the next step would be to transform signal teerms into random complex formula because the first formula we described at the top is not intuitive now.
  //Then, this is again physics ! But, in order to "control" the randomness, we have tto set an exponant term. 11 is good because it is used in physics !
  //But, again, 11 is too high and cannot be computed at the bottom. So, ...
  char* messageToBroadcastToDevices = randomnessControl( "..."+entry_queue->getAngularMomentum()+"...."); //Note that, as this is physics, we can reuse this statement later 
                                                                                                          //because this is not cryptograph science. Then , not suing this at the bottom
                                                                                                          //of this function will be ok and then we increase rapid messages process.
  //taking in mind this last instruction above, this function ends with this last statement below
  //As this is not related to cryptography, we can simply encode command and using RK4 is intuitive but needs 
  //a last formula : .......  (  x + i*y   )^9
  //the formula above was found by trying to write those below lines by scratch ! exponant 9 is not secure.
  //Then, RK4 must be called for an encoded momentum if I m not wrong !  This seems this os not a weapon ! Great ! In th√©t form !
  for(int i=0; i<=9; i++)
  {
    
     RK4_command_encode_and_send( messageToBroadcastToDevices );
  }
  
  async while(1)
    {
          wait_command_1( ... ); //As the last instructions don t matter, we can simply call this above function again and again !
                                 //async keyword seems not secure.
    }


  

 //   char* messageToBroadcastToDevices = randomnessControl( "..."+entry_queue->getAngularMomentum()+"...."); //NO 
 //   send(...); //NO
}

void renderFrame()
{
  //It seems that in the GPUs, it is best to work on stacks because it limits the numbers of computing requests (see notes of supercomput'er repository).
  Stack s;
  
}

